Non-Recursive Path Traversal Filters:

One of the most basic filters against LFI is a search and replace filter, where it simply deletes substrings of (../) to avoid path traversals. For example:

Code: php
$language = str_replace('../', '', $_GET['language']);

Solution:

We see that all ../ substrings were removed, which resulted in a final path being ./languages/etc/passwd.
However, this filter is very insecure,as it is not recursively removing the ../ substring,
as it runs a single time on the input string and does not apply the filter on the output string.
For example, if we use ....// as our payload,
then the filter would remove ../ and the output string would be ../, 
which means we may still perform path traversal.

______________________________________

Encoding:

Some web filters may prevent input filters that include certain LFI-related characters, like a dot . or a slash / used for path traversals.
However, some of these filters may be bypassed by URL encoding our input,
such that it would no longer include these bad characters,
but would still be decoded back to our path traversal string once it reaches the vulnerable function.
Core PHP filters on versions 5.3.4 and earlier were specifically vulnerable to this bypass,
but even on newer versions we may find custom filters that may be bypassed through URL encoding.

______________________________________

Approved Paths:

Some web applications may also use Regular Expressions to ensure that the file being included is under a specific path. For example, the web application we have been dealing with may only accept paths that are under the ./languages directory, as follows:

Code: php
if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
    include($_GET['language']);
} else {
    echo 'Illegal path specified!';
}

Some web applications may apply this filter along with one of the earlier filters,
so we may combine both techniques by starting our payload with the approved path,
and then URL encode our payload or use recursive payload.
______________________________________

Appended Extension:

As discussed in the previous section, some web applications append an extension to our input string (e.g. .php),
to ensure that the file we include is in the expected extension.
There are a couple of other techniques we may use,
but they are obsolete with modern versions of PHP and only work with PHP versions before 5.3/5.4.

-->Path Truncation:

In earlier versions of PHP, defined strings have a maximum length of 4096 characters, likely due to the limitation of 32-bit systems.
If a longer string is passed, it will simply be truncated,
and any characters after the maximum length will be ignored.
,PHP also used to remove trailing slashes and single dots in path names, so if we call (/etc/passwd/.)
then the /. would also be truncated, and PHP would call (/etc/passwd).
PHP, and Linux systems in general, also disregard multiple slashes in the path (e.g. ////etc/passwd is the same as /etc/passwd).
Similarly,a current directory shortcut(.)in the middle of the path would also be disregarded (e.g. /etc/./passwd).
Finally, it is also important to note that we would also need to start the path with a non-existing directory for this technique to work.

An example of such payload would be the following:

Code: url
?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]

Of course, we don't have to manually type ./ 2048 times (total of 4096 characters), but we can automate the creation of this string with the following command:

  Basic Bypasses
Random0@htb[/htb]$ echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done
non_existing_directory/../../../etc/passwd/./././<SNIP>././././


-->Null Bytes:

PHP versions before 5.5 were vulnerable to null byte injection,
which means that adding a null byte (%00) at the end of the string would terminate the string and not consider anything after it.

To exploit this vulnerability, we can end our payload with a null byte (e.g. /etc/passwd%00), such that the final path passed to include() would be (/etc/passwd%00.php).
This way, even though .php is appended to our string, anything after the null byte would be truncated,
and so the path used would actually be /etc/passwd, leading us to bypass the appended extension.
