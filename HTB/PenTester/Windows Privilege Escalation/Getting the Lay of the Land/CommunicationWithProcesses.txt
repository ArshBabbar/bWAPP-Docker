One of the best places to look for privilege escalation is the processes that are running on the system.

------Example------
The most common example is discovering a web server like IIS or XAMPP running on the box,
placing an aspx/php shell on the box, and gaining a shell as the user running the web server.
This is not an administrator but will often have the SeImpersonate token, allowing for Rogue/Juicy/Lonely Potato to provide SYSTEM permissions.

__________________________
Access Tokens

In Windows, access tokens are used to describe the security context (security attributes or rules) of a process or thread.
Every time a user interacts with a process, a copy of this token will be presented to determine their privilege level.
---->>>https://learn.microsoft.com/en-us/windows/win32/secauthz/access-tokens
__________________________
Enumerating Network Services

The most common way people interact with processes is through a network socket (DNS, HTTP, SMB, etc.).
The netstat command will display active TCP and UDP connections which will give us a better idea of what services are listening on which port(s) both locally and accessible to the outside.
Cmd:
netstat -ano

The main thing to look for with Active Network Connections are entries listening on loopback addresses (127.0.0.1 and ::1)
that are not listening on the IP Address (10.129.43.8) or broadcast (0.0.0.0, ::/0).
The one that sticks out immediately will be port 14147, which is used for FileZilla's administrative interface.
By connecting to this port, it may be possible to extract FTP passwords in addition to creating an FTP Share at c:\ as the FileZilla Server user (potentially Administrator).

-----More Examples------

One of the best examples of this type of privilege escalation is the Splunk Universal Forwarder, installed on endpoints to send logs into Splunk.
The default configuration of Splunk did not have any authentication on the software and allowed anyone to deploy applications, which could lead to code execution. 
check out 
Splunk Universal Forwarder Hijacking --->>https://airman604.medium.com/splunk-universal-forwarder-hijacking-5899c3e0e6b2
SplunkWhisperer2--->>>https://clement.notin.org/blog/2019/02/25/Splunk-Universal-Forwarder-Hijacking-2-SplunkWhisperer2/

Another overlooked but common local privilege escalation vector is the Erlang Port (25672).
Many applications that utilize Erlang will either use a weak cookie (RabbitMQ uses rabbit by default) or place the cookie in a configuration file that is not well protected.
For more information check out
Erlang-arce blogpost from Mubix --->>>https://malicious.link/posts/2018/erlang-arce/
__________________________
Named Pipes

The other way processes communicate with each other is through Named Pipes.
Pipes are essentially files stored in memory that get cleared out after being read.

Cobalt Strike uses Named Pipes for every command (excluding BOF). Essentially the workflow looks like this:
 BOF -->>https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm

    Beacon starts a named pipe of \.\pipe\msagent_12
    Beacon starts a new process and injects command into that process directing output to \.\pipe\msagent_12
    Server displays what was written into \.\pipe\msagent_12

Cobalt Strike did this because if the command being ran got flagged by antivirus or crashed, it would not affect the beacon (process running the command).
Cobalt Strike users will change their named pipes to masquerade as another program. One of the most common examples is mojo instead of msagent.
One of my favorite findings was finding a named pipe start with mojo, but the computer itself did not have Chrome installed.
Thankfully, this turned out to be the company's internal red team.

-----More on Named Pipes-----

Pipes are used for communication between two applications or processes using shared memory.
There are two types of pipes, named pipes and anonymous pipes.
An example of a named pipe is \\.\PipeName\\ExampleNamedPipeServer. 

Windows systems use a client-server implementation for pipe communication. In this type of implementation, the process that creates a named pipe is the server, and the process communicating with the named pipe is the client.
Named pipes can communicate using half-duplex, or a one-way channel with the client only being able to write data to the server,
or duplex, which is a two-way communication channel that allows the client to write data over the pipe, and the server to respond back with data over that pipe.
Every active connection to a named pipe server results in the creation of a new named pipe.
These all share the same pipe name but communicate using a different data buffer.

We can use the tool PipeList from the Sysinternals Suite to enumerate instances of named pipes.
PipeList --->>>https://learn.microsoft.com/en-us/sysinternals/downloads/pipelist

Cmd:
pipelist.exe /accepteula

----////---->>>>
Additionally, we can use PowerShell to list named pipes using gci (Get-ChildItem).
Cmd:
gci \\.\pipe\
----////---->>>>

After obtaining a listing of named pipes
We can use Accesschk to enumerate the permissions assigned to a specific named pipe by reviewing the Discretionary Access List (DACL),
which shows us who has the permissions to modify, write, read, or execute a resource.

Let's take a look at the LSASS process. We can also review the DACLs of all named pipes using the command .\accesschk.exe /accepteula \pipe\.

Cmd:
accesschk.exe /accepteula \\.\Pipe\lsass -v

__________________________
Named Pipes Attack Example

This WindscribeService Named Pipe Privilege Escalation is a great example.
Using accesschk we can search for all named pipes that allow write access with a command such as accesschk.exe -w \pipe\* -v
And notice that the WindscribeService named pipe allows READ and WRITE access to the Everyone group, meaning all authenticated users.

__________________________
Checking WindscribeService Named Pipe Permissions

Confirming with accesschk we see that the Everyone group does indeed have FILE_ALL_ACCESS (All possible access rights) over the pipe.
Cmd:
accesschk.exe -accepteula -w \pipe\WindscribeService -v

